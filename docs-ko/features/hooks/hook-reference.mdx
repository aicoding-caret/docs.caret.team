---
title: "Hook 레퍼런스"
sidebarTitle: "Hook 레퍼런스"
description: "Caret Hook 타입별 JSON 스키마, 입력/출력 포맷, 통신 규약을 모두 정리한 레퍼런스"
---

이 문서는 모든 Hook 타입, JSON 스키마, 입출력 포맷, 통신 규약을 포함한 기술 레퍼런스입니다.

## Hook 타입

Caret은 AI 워크플로의 다양한 단계에 연결할 수 있는 Hook 타입을 제공합니다.

<Note>
아래 Hook 이름은 **파일 이름 그대로** 사용해야 합니다. 예를 들어 TaskStart Hook을 사용하려면 hooks 디렉터리에 `TaskStart`(확장자 없음) 파일을 만들어야 합니다.
</Note>

각 Hook은 고유 데이터 외에도 다음 공통 필드를 받습니다: `clineVersion`, `hookName`, `timestamp`, `taskId`, `workspaceRoots`, `userId`.

### 도구 실행 Hook

도구 실행 전후를 가로채 검증/로깅/학습에 활용합니다.

#### `PreToolUse`

Caret이 도구를 실행하기 **직전** 트리거됩니다. 유효성 검증, 정책 적용, 잘못된 작업 차단에 사용합니다. (도구 목록은 [Caret 도구 참조](/exploring-carets-tools/caret-tools-guide) 참고)

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "PreToolUse",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "preToolUse": {
    "toolName": "string",
    "parameters": {}
  }
}
```

**예시:**
```bash
#!/usr/bin/env bash
input=$(cat)

# TypeScript 프로젝트에서 .js 파일 생성 차단
tool_name=$(echo "$input" | jq -r '.preToolUse.toolName')
if [[ "$tool_name" == "write_to_file" ]]; then
  file_path=$(echo "$input" | jq -r '.preToolUse.parameters.path')
  if [[ "$file_path" == *.js ]] && [[ -f "tsconfig.json" ]]; then
    echo '{"cancel": true, "errorMessage": "TypeScript 프로젝트에서는 .js 파일을 생성할 수 없습니다."}'
    exit 0
  fi
fi

echo '{"cancel": false}'
```

#### `PostToolUse`

도구 실행 **직후** 트리거됩니다. 성능 측정, 로그 기록, 결과 학습에 사용합니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "PostToolUse",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "postToolUse": {
    "toolName": "string",
    "parameters": {},
    "result": "string",
    "success": boolean,
    "executionTimeMs": number
  }
}
```

**예시:**
```bash
#!/usr/bin/env bash
input=$(cat)

# 느린 작업을 로그로 기록
execution_time=$(echo "$input" | jq -r '.postToolUse.executionTimeMs')
tool_name=$(echo "$input" | jq -r '.postToolUse.toolName')

if (( execution_time > 5000 )); then
  context="PERFORMANCE: Slow operation detected - $tool_name took ${execution_time}ms"
  echo "{\"cancel\": false, \"contextModification\": \"$context\"}"
else
  echo '{"cancel": false}'
fi
```

### 사용자 상호작용 Hook

사용자 입력을 검증하거나 컨텍스트를 주입하는 데 사용합니다.

#### `UserPromptSubmit`

사용자가 입력을 전송해 **새 작업을 시작**하거나 **완료된 작업을 이어서 진행**할 때 트리거됩니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "UserPromptSubmit",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "userPromptSubmit": {
    "prompt": "string",
    "attachments": ["string"]
  }
}
```

**예시:**
```bash
#!/usr/bin/env bash
input=$(cat)

# 키워드에 따라 코딩 표준 컨텍스트 주입
prompt=$(echo "$input" | jq -r '.userPromptSubmit.prompt')
context=""

if echo "$prompt" | grep -qi "component\|react"; then
  context="CODING_STANDARDS: Follow React functional component patterns with proper TypeScript types"
elif echo "$prompt" | grep -qi "api\|endpoint"; then
  context="CODING_STANDARDS: Use consistent REST API patterns with proper error handling"
fi

if [[ -n "$context" ]]; then
  jq -n --arg ctx "$context" '{"cancel": false, "contextModification": $ctx}'
else
  echo '{"cancel": false}'
fi
```

### 작업 생애주기 Hook

작업 시작부터 완료까지의 상태 변화를 모니터링합니다.

#### `TaskStart`

새 작업이 시작될 때 한 번 트리거됩니다. 프로젝트 타입 감지, 초기 컨텍스트 주입 등에 사용합니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "TaskStart",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "taskStart": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string",
      "initialTask": "string"
    }
  }
}
```

**예시:**
```bash
#!/usr/bin/env bash
input=$(cat)

# 프로젝트 타입 감지 후 컨텍스트 주입
context=""

if [[ -f "package.json" ]]; then
  if grep -q "react" package.json; then
    context="PROJECT_TYPE: React application detected. Follow component-based architecture."
  elif grep -q "express" package.json; then
    context="PROJECT_TYPE: Express.js API detected. Follow RESTful patterns."
  else
    context="PROJECT_TYPE: Node.js project detected."
  fi
elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
  context="PROJECT_TYPE: Python project detected. Follow PEP 8 standards."
elif [[ -f "Cargo.toml" ]]; then
  context="PROJECT_TYPE: Rust project detected. Follow Rust conventions."
fi

if [[ -n "$context" ]]; then
  jq -n --arg ctx "$context" '{"cancel": false, "contextModification": $ctx}'
else
  echo '{"cancel": false}'
fi
```

#### `TaskResume`

취소/중단된 작업을 재개할 때 트리거됩니다. 상태 복원, 컨텍스트 갱신 등에 사용합니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "TaskResume",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "taskResume": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string"
    },
    "previousState": {
      "lastMessageTs": "string",
      "messageCount": "string",
      "conversationHistoryDeleted": "string"
    }
  }
}
```

#### `TaskCancel`

사용자가 작업을 취소하거나 Hook 실행을 중단했을 때 트리거됩니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "TaskCancel",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "taskCancel": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string"
    }
  }
}
```

#### `TaskComplete`

Caret이 작업을 완료하고 `attempt_completion`을 성공적으로 실행했을 때 트리거됩니다.

**입력 필드:**
```json
{
  "clineVersion": "string",
  "hookName": "TaskComplete",
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "taskComplete": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string"
    }
  }
}
```

**예시:**
```bash
#!/usr/bin/env bash
input=$(cat)

# 작업 메타데이터 추출
task_id=$(echo "$input" | jq -r '.taskComplete.taskMetadata.taskId // "unknown"')
ulid=$(echo "$input" | jq -r '.taskComplete.taskMetadata.ulid // "unknown"')

# 완료 로그 기록
completion_log="$HOME/.caret_completions/$(date +%Y-%m-%d).log"
mkdir -p "$(dirname "$completion_log")"

echo "$(date -Iseconds): Task $task_id completed (ULID: $ulid)" >> "$completion_log"

# 완료 컨텍스트 주입
context="TASK_COMPLETED: Task $task_id finished successfully. Completion logged."
jq -n --arg ctx "$context" '{"cancel": false, "contextModification": $ctx}'
```

### 시스템 이벤트 Hook

이 Hook들은 내부 동작과 시스템 이벤트를 모니터링합니다. 컨텍스트 사용량 추적, 동작 로깅, 성능 분석 등에 활용합니다.

## JSON 통신 규약

Hooks는 stdin으로 JSON을 받고 stdout으로 JSON을 반환합니다.

### 입력 포맷

모든 Hook은 아래 구조를 기본으로 사용합니다:

```json
{
  "clineVersion": "string",
  "hookName": "string", 
  "timestamp": "string",
  "taskId": "string",
  "workspaceRoots": ["string"],
  "userId": "string",
  "[hookSpecificField]": {
    // Hook-specific data structure
  }
}
```

### 출력 포맷

Hook 스크립트는 최종 stdout에 아래 JSON을 출력해야 합니다:

```json
{
  "cancel": false,
  "contextModification": "WORKSPACE_RULES: Use TypeScript",
  "errorMessage": "Error details if blocking"
}
```

**필드 설명:**

- **`cancel`** (필수): 실행 계속 여부
  - `true`: 해당 작업 차단
  - `false`: 작업 허용

- **`contextModification`** (선택): 대화에 주입될 컨텍스트 문자열
  - 현재 결정이 아닌 **다음 결정**에 영향을 줌
  - `WORKSPACE_RULES:`, `PERFORMANCE:`, `SECURITY:` 등 분류 가능한 프리픽스 권장
  - 최대 50KB

- **`errorMessage`** (선택): `cancel`이 `true`일 때 사용자에게 표시되는 메시지

### 실행 중 로깅

Hook 스크립트는 실행 중 로그를 출력할 수 있으며, **마지막 출력만 JSON이면 됩니다**:

```bash
#!/usr/bin/env bash
echo "Processing hook..."
echo "Tool: $tool_name"

# 마지막 줄은 JSON
echo '{"cancel": false}'
```

Caret은 stdout의 마지막 JSON만 파싱합니다.

### 오류 처리

Hook 실행 오류는 작업을 중단하지 않습니다. **오직 `"cancel": true`만 작업을 차단**합니다.

**Hook 상태 표시:**

- **Completed** (회색): 정상 실행, 또는 JSON 미반환
- **Failed** (빨강): 비정상 종료/JSON 오류/타임아웃
- **Aborted** (빨강): `cancel: true`로 작업 중단

**중요:** Hook 실패는 작업을 막지 않습니다. 작업을 중단하려면 반드시 `cancel: true`를 반환해야 합니다.

### 컨텍스트 주입 타이밍

컨텍스트 주입은 **현재 결정이 아니라 다음 결정**에 적용됩니다:

1. AI가 작업을 이미 결정
2. Hook이 차단/허용 판단
3. 컨텍스트가 대화에 추가
4. 다음 AI 요청에서 반영

즉,
- **PreToolUse**: 잘못된 동작 차단 + 다음 판단을 위한 컨텍스트 주입
- **PostToolUse**: 결과 학습용 컨텍스트 주입

### JSON 이스케이프 팁

JSON 문자열에 따옴표가 포함될 때는 jq의 `--arg`를 사용하세요:

```bash
#!/usr/bin/env bash

output='{"foo":"bar"}'

jq -n --arg ctx "$output" '{cancel: false, contextModification: $ctx}'
```

이렇게 하면 특수 문자가 자동으로 이스케이프되어 JSON 파싱 오류를 예방할 수 있습니다.

## Hook 실행 환경

### 실행 컨텍스트

Hooks는 VS Code와 동일한 권한으로 실행됩니다. 다음에 접근할 수 있습니다:
- 전체 파일 시스템
- 모든 환경 변수
- 시스템 명령/도구
- 네트워크 리소스

즉, 사용자가 터미널에서 할 수 있는 모든 작업을 수행할 수 있습니다.

### 보안 주의사항

<Warning>
Hooks는 VS Code와 동일한 권한으로 실행됩니다. 신뢰할 수 없는 Hook은 활성화하기 전에 반드시 검토하세요.
</Warning>

### 성능 가이드

Hooks는 **30초 타임아웃**이 있습니다. 그 안에서 네트워크 호출이나 무거운 연산도 가능하지만, 장시간 작업은 피하세요.

### Hook 검색 경로

Caret은 다음 순서로 Hook을 찾습니다:

1. 프로젝트 Hooks: 워크스페이스 루트의 `.agents/hooks/`
2. 전역 Hooks: `~/Documents/Caret/Hooks/`

같은 이름의 Hook이 있을 경우 **프로젝트 Hook이 우선**됩니다.
