---
title: "GitHub 이슈 RCA 샘플"
description: "캐러티 CLI로 GitHub 이슈를 자동 분석해 근본 원인을 찾습니다."
---

# GitHub 근본 원인 분석

캐러티 CLI를 사용한 GitHub 이슈 자동 분석 샘플입니다. 캐러티의 자율 AI 기능으로 이슈를 가져오고 분석해 근본 원인을 찾으며, 워크플로우에 쉽게 통합할 수 있는 깔끔한 출력 결과를 제공합니다.

<Note>
**캐러티 CLI가 처음이신가요?** 이 샘플은 [설치 가이드](/ko/caret-cli/installation)를 완료하고 `caret auth`로 인증했다고 가정합니다. 아직 캐러티 CLI를 설정하지 않았다면 먼저 설치를 완료하세요.
</Note>

<Frame>
  <img src="https://storage.googleapis.com/cline_public_images/cli-rca.gif" alt="CLI Root Cause Analysis Demo" width="600" />
</Frame>

## 준비 사항

이 샘플은 다음을 이미 완료했다고 가정합니다:

- **캐러티 CLI** 설치 및 인증 완료 ([설치 가이드](/ko/caret-cli/installation))
- **최소 1개의 AI 모델 프로바이더** 설정 (예: OpenRouter, Anthropic, OpenAI)
- **캐러티 CLI 기본 사용법** 이해

추가로 다음이 필요합니다:

- **GitHub CLI**(`gh`) 설치 및 인증
- **jq** 설치 (JSON 파싱용)
- **bash** 쉘(또는 호환 쉘)

### 설치 방법

#### macOS

<Note>
이 과정은 [Homebrew](https://brew.sh/)가 설치되어 있어야 합니다. 없으면 아래 명령으로 먼저 설치하세요:
```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```
</Note>

```bash
# GitHub CLI 설치
brew install gh

# jq 설치
brew install jq

# GitHub 인증
gh auth login
```

#### Linux

```bash
# GitHub CLI 설치 (Debian/Ubuntu)
sudo apt install gh

# 다른 배포판은 여기 참고: https://cli.github.com/manual/installation

# jq 설치 (Debian/Ubuntu)
sudo apt install jq

# GitHub 인증
gh auth login
```

## 스크립트 받기

**옵션 1: curl로 직접 다운로드**
```bash
curl -O https://raw.githubusercontent.com/caret/caret/main/src/samples/cli/github-issue-rca/analyze-issue.sh
```

**옵션 2: 전체 스크립트 복사**

<Accordion title="analyze-issue.sh 전체 보기">

```bash
#!/bin/bash
# Analyze a GitHub issue using 캐러티 CLI

if [ -z "$1" ]; then
    echo "Usage: $0 <github-issue-url> [prompt] [address]"
    echo "Example: $0 https://github.com/owner/repo/issues/123"
    echo "Example: $0 https://github.com/owner/repo/issues/123 'What is the root cause of this issue?'"
    echo "Example: $0 https://github.com/owner/repo/issues/123 'What is the root cause of this issue?' 127.0.0.1:46529"
    exit 1
fi

# Gather the args
ISSUE_URL="$1"
PROMPT="${2:-What is the root cause of this issue?}"
if [ -n "$3" ]; then
    ADDRESS="--address $3"
fi

# Ask 캐러티 for its analysis, showing only the summary
caret -y "$PROMPT: $ISSUE_URL" --mode act $ADDRESS -F json | \
    sed -n '/^{/,$p' | \
    jq -r 'select(.say == "completion_result") | .text' | \
    sed 's/\\n/\n/g'
```

</Accordion>

<Note>
**스크립트를 다운로드하거나 만든 뒤**, 실행 권한을 부여하세요:
```bash
chmod +x analyze-issue.sh
```
</Note>

## 빠른 사용 예시

### 기본 사용

스크립트를 저장한 디렉터리에서 아래 명령을 실행하면 기본 프롬프트로 이슈를 분석합니다:

```bash
./analyze-issue.sh https://github.com/owner/repo/issues/123
```

이 과정에서 다음이 수행됩니다:
- 저장소의 123번 이슈를 가져옴
- 이슈의 근본 원인을 분석
- 권장 사항을 포함한 상세 분석 제공

### 커스텀 프롬프트

이슈에 대해 특정 질문을 던질 수 있습니다:

```bash
./analyze-issue.sh https://github.com/owner/repo/issues/456 "What is the security impact?"
```

### 특정 인스턴스 사용

특정 캐러티 인스턴스 주소를 지정해 분석할 수 있습니다:

```bash
./analyze-issue.sh https://github.com/owner/repo/issues/123 \
    "What is the root cause of this issue?" \
    127.0.0.1:46529
```

<Warning>
다음 상황에서 유용합니다:
- 여러 캐러티 인스턴스를 실행 중인 경우
- 원격 캐러티 서버를 사용하는 경우
- 특정 구성으로 테스트하려는 경우
</Warning>

<Note>
스크립트가 이슈를 가져오고 캐러티로 분석한 뒤 결과를 표시하는 모든 작업을 자동으로 처리합니다. 이슈 복잡도에 따라 보통 30~60초가 소요됩니다.
</Note>

## 동작 원리

스크립트의 각 부분을 살펴보며 동작 방식을 이해해 봅니다.

### 인자 검증

입력값을 검증하고 사용법을 안내합니다:

```bash
if [ -z "$1" ]; then
    echo "Usage: $0 <github-issue-url> [prompt] [address]"
    echo "Example: $0 https://github.com/owner/repo/issues/123"
    echo "Example: $0 https://github.com/owner/repo/issues/123 'What is the root cause?'"
    echo "Example: $0 https://github.com/owner/repo/issues/123 'Analyze security impact' 127.0.0.1:46529"
    exit 1
fi
```

**핵심 포인트:**
- GitHub 이슈 URL 필수 검증
- 명확한 사용 예시 제공
- 커스텀 프롬프트 지원
- 캐러티 인스턴스 주소 선택 지원

### 인자 파싱

인자를 추출해 설정합니다:

```bash
# Gather the args
ISSUE_URL="$1"
PROMPT="${2:-What is the root cause of this issue?}"
if [ -n "$3" ]; then
    ADDRESS="--address $3"
fi
```

**설명:**
- `ISSUE_URL="$1"` - 첫 번째 인자는 이슈 URL
- `PROMPT="${2:-...}"` - 두 번째 인자는 선택, 기본값은 원인 분석
- `ADDRESS` - 세 번째 인자(선택)로 인스턴스 주소 지정

### 핵심 분석 파이프라인

실제 분석이 일어나는 부분입니다:

```bash
# Ask 캐러티 for his analysis, showing only the summary
caret -y "$PROMPT: $ISSUE_URL" --mode act $ADDRESS -F json | \
    sed -n '/^{/,$p' | \
    jq -r 'select(.say == "completion_result") | .text' | \
    sed 's/\\n/\n/g'
```

<Accordion title="파이프라인 해설: 각 구성 요소 이해하기">

**1. `caret -y "$PROMPT: $ISSUE_URL"`**
   - `-y`는 yolo 모드(무인 실행)
   - 이슈 URL을 포함한 프롬프트 구성

**2. `--mode act`**
   - act 모드 활성화
   - 파일 읽기/명령 실행 등 도구 사용 가능

**3. `$ADDRESS`**
   - 특정 인스턴스 주소 선택(있을 때만)

**4. `-F json`**
   - JSON 포맷으로 출력

**5. `sed -n '/^{/,$p'`**
   - 출력에서 JSON 부분만 추출

**6. `jq -r 'select(.say == "completion_result") | .text'`**
   - 완료 결과 메시지만 필터링
   - 텍스트 필드 추출

**7. `sed 's/\\n/\n/g'`**
   - 이스케이프된 줄바꿈을 실제 줄바꿈으로 변환

</Accordion>

## 샘플 출력

실제 Flutter 이슈를 분석한 예시입니다:

```bash
$ ./analyze-issue.sh https://github.com/csells/flutter_counter/issues/2
```

**출력:**

```markdown
**Root Cause Analysis of Issue #2: "setState isn't cutting it"**

After examining the GitHub issue and analyzing the Flutter counter codebase, 
I've identified the root cause of why setState() is insufficient for this 
project's needs:

## Current Implementation Problems

The current Flutter counter app uses setState() for state management, which 
has several limitations:

1. **Local State Only**: setState() only works within a single widget, making 
   it difficult to share state across the app
2. **Rebuild Overhead**: Every setState() call rebuilds the entire widget tree, 
   causing performance issues with complex UIs
3. **No State Persistence**: State is lost when the widget is disposed
4. **Testing Challenges**: setState-based logic is tightly coupled to the UI, 
   making unit testing difficult

## Why This Matters

As the app grows beyond a simple counter, these limitations become critical:
- Multiple screens need to access the count
- State needs to persist across navigation
- Business logic should be testable independently
- UI should only rebuild when necessary

## Recommended Solutions

The issue mentions "Provider or Bloc" - both are excellent alternatives:

1. **Provider**: Simple, lightweight state management using InheritedWidget
   - Easy migration path from setState
   - Good for small to medium apps
   - Official Flutter recommendation

2. **Bloc**: More structured approach with clear separation between events, 
   states, and business logic
   - Better for complex apps
   - Excellent testability
   - Clear architectural patterns

3. **Riverpod**: Modern alternative to Provider with better performance and 
   developer experience
   - Compile-time safety
   - Better testing support
   - More flexible than Provider

4. **GetX**: Full-featured solution with state management, routing, and 
   dependency injection
   - Minimal boilerplate
   - Fast and lightweight
   - All-in-one solution

## Next Steps

The current codebase needs refactoring to implement proper state management 
architecture to handle more complex state scenarios effectively. Provider 
would be the easiest migration path while Bloc provides better long-term 
scalability.
```

## 언제 이 패턴을 사용하나요?

자동 GitHub 이슈 분석이 워크플로우를 가속하는 다양한 상황에 적합합니다.

### 버그 조사

버그 리포트를 빠르게 분석하고 근본 원인을 찾습니다:

```bash
./analyze-issue.sh https://github.com/project/repo/issues/123 \
    "What is the root cause of this bug?"
```

### 기능 요청 분석

기능 요청의 맥락과 영향 범위를 이해합니다:

```bash
./analyze-issue.sh https://github.com/project/repo/issues/456 \
    "What are the implementation challenges?"
```

### 보안 점검

보안 이슈의 영향을 평가합니다:

```bash
./analyze-issue.sh https://github.com/project/repo/issues/789 \
    "What are the security implications?"
```

### 문서 생성

이슈 기반의 기술 문서를 자동 생성합니다:

```bash
./analyze-issue.sh https://github.com/project/repo/issues/654 \
    "Provide detailed technical documentation for this issue"
```

### 코드 리뷰 지원

제안된 변경에 대한 2차 의견을 얻습니다:

```bash
./analyze-issue.sh https://github.com/project/repo/issues/987 \
    "Review the proposed solution approach"
```

## 결론

이 샘플은 캐러티 CLI로 GitHub 이슈 분석 도구를 구축하는 방법을 보여줍니다:

1. 캐러티의 기능을 활용한 **자율 CLI 도구** 구축
2. 캐러티 CLI **JSON 출력 파싱**
3. 커스텀 프롬프트 기반 **유연한 자동화 스크립트** 작성
4. GitHub 이슈 분석 **통합**
5. **명령줄 인자 처리**의 모범 패턴

이 패턴은 PR 리뷰, 문서 생성, 코드 품질 분석 등 다양한 자동화 시나리오로 확장할 수 있습니다.

## 관련 자료

- [CLI 설치 가이드](/ko/caret-cli/installation)
- [CLI 레퍼런스](/ko/caret-cli/cli-reference)
- [3가지 핵심 흐름](/ko/caret-cli/three-core-flows)
