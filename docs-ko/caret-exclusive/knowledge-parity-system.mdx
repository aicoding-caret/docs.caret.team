---
sidebar_position: 8
title: ^ AI 조직 지식 및 규칙 표준화
description: AI가 팀의 규칙과 표준을 정확히 따르도록 보장하는 캐러티의 핵심 시스템을 소개합니다.
---

# ^ AI 조직 지식 및 규칙 표준화

캐러티는 AI가 **팀의 코딩 규칙과 표준을 정확히 이해하고 따르도록** 설계되었습니다. 이 시스템을 통해 AI는 단순한 코드 생성 도구가 아닌, 프로젝트 맥락을 이해하는 진정한 팀원으로 기능합니다.

## 왜 지식 동기화가 중요한가요?

| 상황 | 일반 AI 도구 | 캐러티 |
|---|---|---|
| **팀 규칙 준수** | 규칙을 모름 | ✅ 규칙 파일을 자동으로 인식 |
| **프로젝트 맥락** | 매번 설명 필요 | ✅ 지속적으로 기억 |
| **코드 일관성** | 도구마다 다른 스타일 | ✅ 팀 표준 유지 |
| **역할별 최적화** | 없음 | ✅ AI용/사람용 문서 분리 |

## 핵심 개념 1: 이중 디렉토리 아키텍처

캐러티는 **AI와 사람이 읽는 문서의 목적이 다르다**는 점을 인정합니다. 이를 위해 두 개의 디렉토리를 사용합니다:

```
your-project/
├── .agents/                    # AI용 (영어, 토큰 최적화)
│   ├── context/               # 시스템 규칙
│   │   ├── agents-rules.json  # 메인 규칙 파일 (SoT)
│   │   └── ai-work-index.yaml # 작업 인덱스
│   ├── workflows/             # 작업 워크플로우
│   │   └── atoms/             # 재사용 가능한 빌딩 블록
│   ├── skills/                # AI 스킬
│   └── hooks/                 # 이벤트 훅
│
├── .users/                     # 사람용 (네이티브 언어, 상세)
│   ├── context/               # 프로젝트 컨텍스트 (Markdown)
│   ├── workflows/             # 워크플로우 가이드
│   └── skills/                # 스킬 가이드
│
└── AGENTS.md                   # AI 진입점
```

### 왜 분리하나요?

| 구분 | `.agents/` (AI용) | `.users/` (사람용) |
|------|-------------------|-------------------|
| **언어** | 영어 (토큰 효율) | 네이티브 언어 |
| **형식** | JSON/YAML (구조화) | Markdown (가독성) |
| **목적** | 결정적 동작 보장 | 상세한 설명 제공 |
| **대상** | AI 에이전트 | 개발자/팀원 |

**토큰 최적화**: AI가 읽는 `.agents/` 파일은 영어로 작성하여 같은 의미를 더 적은 토큰으로 전달합니다. 이는 컨텍스트 창을 효율적으로 사용하고 비용을 절감합니다.

## 핵심 개념 2: Atomic Knowledge System

캐러티는 **지식 원자화(Atomic Knowledge)** 방식을 사용합니다. 거대한 단일 문서 대신, 지식을 최소 단위(Atom)로 쪼개고 필요할 때 조합합니다.

### 동작 방식

1. **작업 분석**: AI가 `ai-work-index.yaml`을 읽고 작업 유형을 파악
2. **워크플로우 로드**: 해당 작업의 워크플로우 파일만 읽음
3. **지식 원자 조합**: 워크플로우가 참조하는 atoms만 추가 로드
4. **작업 수행**: 조합된 지식으로 작업 수행

### 예시

```
.agents/workflows/
├── code-review.md             # 코드 리뷰 워크플로우
├── feature-implementation.md  # 기능 구현 워크플로우
└── atoms/                     # 재사용 가능한 빌딩 블록
    ├── tdd-cycle.md           # TDD 사이클
    ├── naming-conventions.md  # 네이밍 규칙
    └── document-changes.md    # 변경사항 문서화
```

**장점**: AI가 모든 규칙을 항상 로드하는 대신, 현재 작업에 필요한 규칙만 선별적으로 로드하여 **토큰을 절약**합니다.

## 핵심 개념 3: 규칙 위치 및 우선순위

캐러티는 **`.agents/context/`** 폴더를 단일 규칙 소스로 사용합니다. 이를 통해 AI가 프로젝트 전체에서 일관된 표준을 따릅니다.

### 규칙 위치

| 유형 | 위치 | 용도 |
|------|------|------|
| **워크스페이스 규칙** | `.agents/context/` | 프로젝트별 규칙 |
| **디렉토리 범위** | `AGENTS.md` | 특정 폴더에만 적용 |
| **전역 규칙** | `Documents/캐러티/Rules` | 모든 프로젝트에 적용 |
| **워크플로우** | `.agents/workflows/` | 온디맨드 로딩 |

### 왜 표준화가 중요한가요?

| 문제 | 해결 |
|------|------|
| 여러 곳에 규칙이 분산됨 | 한 곳에서 관리 |
| 규칙 충돌 발생 | 우선순위 명확화 |
| AI가 규칙을 놓침 | 자동 로딩 보장 |

## 핵심 개념 4: 조직간 지식 동기화

서브모듈을 활용하면 **조직 전체의 규칙과 지식을 여러 프로젝트에서 공유**할 수 있습니다.

### 조직 저장소 패턴

```
org-context/                      # 조직 공유 저장소 (Git)
├── .agents/                      # AI 컨텍스트
│   ├── context/                  # 조직 규칙/정책
│   │   ├── conventions.md        # 개발 규칙
│   │   ├── tech-stack.md         # 기술 스택
│   │   └── security-policy.md    # 보안 정책
│   └── workflows/                # 워크플로우 정의
│       ├── code-review.md
│       └── release-process.md
│
├── .users/                       # 사용자 문서 (미러링)
│   ├── context/
│   │   ├── 개발표준.md           # 상세 가이드
│   │   └── 기술스택.md
│   └── workflows/
│       └── 코드리뷰-가이드.md
│
└── AGENTS.md                     # 조직 AI 진입점
```

### 프로젝트에 서브모듈로 연결

```bash
# 조직 컨텍스트를 서브모듈로 추가
git submodule add git@github.com:your-org/org-context.git
```

```
your-project/
├── .agents/                # 프로젝트 규칙
├── .users/                 # 프로젝트 사용자 문서
├── org-context/            # ← 서브모듈 (조직 규칙)
│   ├── .agents/
│   └── .users/
└── AGENTS.md
```

### 4계층 규칙 병합

```
Layer 1: Global (사용자 전역)
    ~/.agents/                    # 개인 AI 규칙

Layer 2: Organization (조직)
    org-context/.agents/          # 조직 AI 컨텍스트

Layer 3: Project (프로젝트)
    {project}/.agents/            # 프로젝트 AI 규칙

Layer 4: Local (디렉토리별)
    {project}/packages/{pkg}/
    └── AGENTS.md                 # 디렉토리별 오버라이드

병합 우선순위: Local > Project > Organization > Global
```

### 사용 시나리오

```bash
# 한 프로젝트에서 모든 작업 가능:

# 코딩 작업
"이 함수 리팩토링해줘"
→ .agents/context/ 규칙 참조하여 작업

# 회사 정책 질문
"재택근무 규정 알려줘"
→ org-context/.users/policies/근무규정.md 읽고 답변

# 워크플로우 가이드
"코드 리뷰 어떻게 하는거야?"
→ org-context/.users/workflows/코드리뷰-가이드.md 참조
```

## 빠른 시작: `/init` 명령

프로젝트에 표준 구조가 없으면 `/init` 명령으로 자동 생성할 수 있습니다.

```bash
# 캐러티 채팅에서
/init
```

이 명령은:
- `.agents/` 및 `.users/` 폴더 구조를 생성합니다
- 기본 규칙 템플릿을 제공합니다
- **기존 파일은 덮어쓰지 않습니다** (안전함)

## 기존 프로젝트 마이그레이션

다른 위치에 규칙 파일이 있다면 `.agents/context/`로 이동하세요.

```
your-project/
├── .agents/
│   ├── context/          # 규칙 파일
│   │   └── coding.md     # 예: 코딩 표준
│   └── workflows/        # 워크플로우 (선택)
└── AGENTS.md             # 루트 지시사항 (선택)
```

## 주요 이점

### 1. 진정한 파트너십
AI와 개발자가 동일한 문서를 기반으로 소통하여 오해의 소지를 없앱니다.

### 2. 토큰 효율성
- 영어로 작성된 `.agents/` 파일로 토큰 절감
- On-Demand Loading으로 필요한 규칙만 로드

### 3. 조직 전체 일관성
서브모듈을 통해 모든 프로젝트가 동일한 조직 규칙을 공유합니다.

### 4. 투명성
개발자는 `.agents/` 폴더를 통해 AI가 어떤 절차로 작업하는지 명확히 알 수 있습니다.

### 5. 팀 일관성
- 모든 팀원이 동일한 규칙 사용
- AI 신뢰성 - 규칙을 놓치는 일 없음
- 버전 관리 - 규칙 변경 이력 추적
- 유연한 범위 - 프로젝트/폴더/전역 선택

## Cline과의 전체 비교

| 항목 | Cline | 캐러티 |
|------|-------|-------|
| **지식 공유** | 단일 파일 (단순 텍스트) | Atomic Knowledge System |
| **효율성** | 모든 규칙 항상 로드 | On-Demand Loading |
| **역할 분리** | 없음 | AI용/사람용 분리 |
| **부트스트랩** | 수동 설정 | `/init` 자동 스캐폴드 |
| **조직 공유** | 없음 | 서브모듈 패턴 지원 |
| **규칙 우선순위** | 불명확 | 4계층 명확한 병합 |

## 시작하기

### 방법 1: 자동 초기화 (권장)
```bash
# 캐러티 채팅에서
/init
```

### 방법 2: 수동 설정
1. 프로젝트 루트에 `.agents/context/` 폴더 생성
2. Markdown 파일로 규칙 작성
3. 캐러티와 대화 시작

자세한 규칙 작성 방법은 [캐러티 규칙 기능](/ko/features/caret-rules) 문서를 참고하세요.

## 관련 문서

- [캐러티 규칙 기능](/ko/features/caret-rules) - 규칙 작성 가이드
- [문서 읽기 도구](/ko/caret-exclusive/document-tools) - AI가 문서를 직접 읽는 기능
- [이미지 도구](/ko/caret-exclusive/image-tools) - AI 이미지 생성/분석 기능
