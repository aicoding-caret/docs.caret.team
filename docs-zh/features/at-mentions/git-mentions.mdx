---
title: "Git 引用"
sidebarTitle: "Git 引用"
---

Git 引用让您可以将仓库的历史和变更直接带入与 Caret 的对话中。您可以使用 `@git-changes` 引用未提交的更改,或使用 `@[commit-hash]` 引用特定的提交。

在聊天中输入 `@` 时,您可以从菜单中选择"Git Changes"或直接输入 `@git-changes`。对于特定的提交,输入 `@` 后跟提交哈希值(至少 7 个字符)。Caret 会立即看到 git 状态、差异、提交消息和其他相关信息。

当我尝试理解代码更改或排查最近提交引入的问题时,我经常使用 git 引用。不用尝试复制粘贴差异或提交日志,我只需询问:

```
我认为这个提交破坏了我们的身份验证流程: @a1b2c3d

你能解释一下发生了什么变化以及为什么可能导致这个问题吗?
```

这让 Caret 获得完整的提交信息,包括提交消息、作者、日期和完整的差异。然后 Caret 可以准确分析发生了什么变化以及它如何影响代码库的其他部分。

当您正在处理更改并希望在提交之前获得反馈时,`@git-changes` 引用非常完美:

```
这是我当前的更改: @git-changes

我正在尝试为用户配置文件实现一个新功能。我的方法合理吗?
有什么潜在的问题或改进建议吗?
```

这会向 Caret 展示您所有未提交的更改,包括新文件、修改的文件及其差异。然后 Caret 可以审查您的更改并提供关于您的实现的反馈。

Git 引用与文件引用结合使用时特别强大。当我调查 bug 时,我经常同时引用两者:

```
我认为这个提交引入了一个 bug: @a1b2c3d

这是当前的实现: @/src/components/Auth.jsx

我该如何修复问题同时保留预期的功能?
```

下次处理代码更改或调查问题时,尝试使用 git 引用而不是手动描述或复制更改。您将获得更准确的帮助,因为 Caret 可以确切地看到发生了什么变化以及在什么上下文中。

## 工作原理

当您在消息中使用 git 引用时,后台发生的情况如下:

### 对于 Git Changes (`@git-changes`)

1. 当您发送消息时,Caret 会检测文本中的 `@git-changes` 模式
2. 扩展运行 git 命令来获取仓库的当前工作状态
3. 它捕获 `git status` 和 `git diff` 的输出以查看所有未提交的更改
4. 这些信息以结构化格式附加到您的消息中:

    ```
    <git_working_state>
    On branch main
    Changes not staged for commit:
      modified: src/components/Button.jsx
      modified: src/styles/main.css

    [所有更改的完整差异输出]
    </git_working_state>
    ```

### 对于特定提交 (`@[commit-hash]`)

1. 当您发送消息时,Caret 会检测 `@` 后跟提交哈希值的模式
2. 扩展运行 `git show` 和相关命令来获取该提交的信息
3. 它检索提交消息、作者、日期和完整的差异
4. 这些信息以结构化格式附加到您的消息中:

    ```
    <git_commit hash="a1b2c3d">
    commit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t
    Author: Developer Name <dev@example.com>
    Date: Mon May 20 14:30:45 2025 -0700

    Fix authentication bug in login form

    [显示提交中所有更改的完整差异输出]
    </git_commit>
    ```

每当您使用 git 引用时,这个过程都会自动发生,让 AI 完全了解您的代码更改,而无需复制粘贴差异或提交日志。
