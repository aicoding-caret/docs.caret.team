---
title: "上下文管理"
description: "上下文是充分利用 Caret 的关键"
---

> **快速参考**
>
> -   上下文 = Caret 对您项目了解的信息
> -   上下文窗口 = Caret 一次可以保存的信息量
> -   使用上下文文件来维护项目知识
> -   当上下文窗口填满时重置

## 理解上下文和上下文窗口


	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/image%20(2).png"
		alt="In a world of infinite context, the context window is what Caret currently has available"
	/>


把与 Caret 合作想象成与一个彻底、主动的团队成员协作：

### 上下文是如何构建的

Caret 通过两种方式主动构建上下文:

1. **自动上下文收集(即 Caret 驱动)**
    - 主动读取相关文件
    - 探索项目结构
    - 分析模式和关系
    - 映射依赖项和导入
    - 提出澄清性问题
2. **用户引导的上下文**
    - 共享特定文件
    - 提供文档
    - 回答 Caret 的问题
    - 引导关注领域
    - 分享设计思路和需求

**要点**: Caret 不是被动的 - 它主动寻求理解您的项目。您可以让它自由探索，也可以引导它的关注点，特别是在[计划模式](/zh/features/plan-and-act)中。

### 上下文与上下文窗口

将上下文想象成您和 Caret 共享的白板:

-   **上下文**是所有可用的信息:
    -   Caret 发现的内容
    -   您共享的内容
    -   您的对话历史
    -   项目需求
    -   以前的决策
-   **上下文窗口**是白板本身的大小:
    -   以令牌(token)为单位测量(1个令牌 ≈ 3/4个英文单词)
    -   每个模型都有固定的大小:
        -   Claude Sonnet 4: 1,000,000 令牌
        -   Qwen3 Coder: 256,000 令牌
        -   Gemini 2.5 Pro: 1,000,000+ 令牌
        -   GPT-5: 400,000 令牌
    -   当白板满了时，Caret 会自动总结对话以释放空间

**重要提示**: 拥有大的上下文窗口并不意味着您应该完全填满它。即使模型声称有更高的限制，模型在大约 400-500K 令牌时就会开始降级。就像一个杂乱的白板一样，太多的信息会使您更难专注于重要的内容。

## 理解上下文窗口进度条

Caret 提供了一种可视化的方式来监控您的上下文窗口使用情况:


	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/image%20(1)%20(1).png"
		alt="上下文窗口进度条"
	/>


### 读取进度条

-   ↑ 显示输入令牌(您发送给 LLM 的内容)
-   ↓ 显示输出令牌(LLM 生成的内容)
-   进度条可视化显示您已使用的上下文窗口量
-   总数显示您的模型的最大容量(例如，Claude Sonnet 4 为 1M)

### 何时关注进度条

-   在长时间编码会话期间
-   处理多个文件时
-   开始复杂任务之前
-   当 Caret 似乎失去上下文时

**提示**: 使用[自动压缩](/zh/features/auto-compact)，Caret 现在可以自动处理长对话。与[焦点链](/zh/features/focus-chain)结合使用时，您可以处理跨越多个上下文窗口的复杂项目而不会丢失进度。

## 自动上下文管理

Caret 包含智能功能来自动管理上下文:

### 应保持启用的默认设置

**焦点链** - 在 v3.25 中默认启用。Caret 在任务开始时生成待办事项列表并将其保留在上下文中，以便线程不会偏离。您可以编辑 markdown 以添加或重新排序步骤，Caret 会相应调整。[了解更多关于焦点链的信息](/zh/features/focus-chain)。

**自动压缩** - 始终启用。当上下文窗口达到其限制时，Caret 会创建一个全面的摘要，替换臃肿的历史记录，并从中断处继续。决策、代码更改和状态都会被保留。[了解更多关于自动压缩的信息](/zh/features/auto-compact)。

## 高级上下文工具

当您需要对上下文管理进行更多控制时:

### 深度规划 (`/deep-planning`)
用于重大功能、重构或集成。Caret 调查您的代码库，提出有针对性的问题，然后编写 `implementation_plan.md`。它创建一个具有精炼高价值上下文的新任务。[了解更多关于深度规划的信息](/zh/features/slash-commands/deep-planning)。

### 新任务 (`/newtask`)
在自然过渡点，仅将重要内容打包到新任务中。研究后实现的干净起点，或团队成员之间的清晰交接。[了解更多关于新任务的信息](/zh/features/slash-commands/new-task)。

### Smol (`/smol`)
在原地压缩对话以保持动力。在调试或探索性工作中理想使用，当您不想中断流程时。[了解更多关于 Smol 的信息](/zh/features/slash-commands/smol)。

### 内存库 + .clinerules
用于非平凡项目。内存库将项目知识作为 Markdown 捕获在您的存储库中。`.clinerules` 是版本控制的指令，使 Caret 的行为与您的团队保持一致。[了解更多关于内存库的信息](/zh/prompting/caret-memory-bank)和 [Caret 规则](/zh/features/caret-rules)。

## 使用上下文文件

上下文文件有助于在会话之间保持理解。它们作为专门设计用于帮助 AI 助手理解您的项目的文档。

#### 上下文文件的方法

1. **常青项目上下文(内存库)**
    - 随着项目发展而演变的实时文档
    - 随着架构和模式的出现而更新
    - 示例: 内存库模式维护像 `techContext.md` 和 `systemPatterns.md` 这样的文件
    - 对长期项目和团队有用
2. **特定任务上下文**

    - 为特定实现任务创建
    - 记录需求、约束和决策
    - 示例:

        ```markdown
        # auth-system-implementation.md

        ## Requirements

        -   OAuth2 implementation
        -   Support for Google and GitHub
        -   Rate limiting on auth endpoints

        ## Technical Decisions

        -   Using Passport.js for provider integration
        -   JWT for session management
        -   Redis for rate limiting
        ```

3. **知识转移文档**
    - 切换到计划模式并要求 Caret 在 markdown 文件中记录到目前为止您完成的所有内容以及剩余步骤。
    - 复制 markdown 文件的内容。
    - 使用该内容作为上下文开始新任务。

#### 有效使用上下文文件

1. **结构和格式**
    - 使用清晰、一致的组织
    - 包括相关示例
    - 链接相关概念
    - 保持信息集中
2. **维护**
    - 在重大更改后更新
    - 对上下文文件进行版本控制
    - 删除过时信息
    - 记录关键决策

## 实用技巧

1. **开始新项目**
    - 让 Caret 探索代码库
    - 回答关于结构和模式的问题
    - 考虑设置基本的上下文文件
    - 记录关键设计决策
2. **持续开发**
    - 使用重大更改更新上下文文件
    - 共享相关文档
    - 使用计划模式进行复杂讨论
    - 在需要时开始新会话
3. **团队项目**
    - 共享常用上下文文件(考虑在项目根目录中使用 [.clinerules](/zh/features/caret-rules) 文件)
    - 记录架构决策
    - 保持一致的模式
    - 保持文档最新

## 额外的上下文技巧

- 您可以 @ 链接并将网页的上下文添加到 Caret (文档、博客等)
- 利用 MCP 服务器从外部知识库中提取上下文
- 屏幕截图可以用作支持图像输入的模型的上下文

## 总结

Caret 已经为您做了很多上下文工作 - [焦点链](/zh/features/focus-chain)、[自动压缩](/zh/features/auto-compact) 和规划流程旨在在长时间范围内保持线程完整。目标是帮助 Caret 在会话之间保持对项目的一致理解。

记住: 目标是在每一步只保留重要的内容。
