---
title: "Commande Deep Planning"
sidebarTitle: "/deep-planning"
---

`/deep-planning` transforme Caret en un architecte méticuleux qui examine votre codebase, pose des questions de clarification et crée un plan d'implémentation complet avant d'écrire une seule ligne de code.

<Frame>
	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/deep-planning.png"
		alt="Deep Planning command in action showing investigation and planning process"
	/>
</Frame>

Lorsque vous utilisez `/deep-planning`, Caret suit un processus en quatre étapes qui reflète la manière dont les développeurs expérimentés abordent les fonctionnalités complexes : investigation approfondie, discussion et clarification des exigences, planification détaillée et création de tâches structurées avec suivi des progrès.

## Le processus en quatre étapes

### Étape 1 : Investigation silencieuse

Caret devient un détective, explorant silencieusement votre codebase pour comprendre sa structure, ses modèles et ses contraintes. Il examine les fichiers sources, analyse les modèles d'importation, découvre les hiérarchies de classes et identifie les marqueurs de dette technique. Pas de commentaires, pas de narration, juste une recherche ciblée.

Pendant cette phase, Caret exécute des commandes telles que :
- Trouver toutes les définitions de classes et de fonctions dans votre codebase
- Analyser les modèles d'importation pour comprendre les dépendances
- Découvrir la structure du projet et l'organisation des fichiers
- Identifier les TODO et la dette technique

### Étape 2 : Discussion et questions

Une fois que Caret comprend votre codebase, il pose des questions ciblées qui façonneront l'implémentation. Ce ne sont pas des questions génériques, elles sont spécifiques à votre projet et à la fonctionnalité que vous créez.

Les questions peuvent porter sur :
- Clarifier les exigences ambiguës
- Choisir entre des approches d'implémentation également valables
- Confirmer les hypothèses sur le comportement du système
- Comprendre les préférences pour les décisions techniques

### Étape 3 : Document de plan d'implémentation

Caret crée un document markdown structuré (`implementation_plan.md`) qui sert de plan d'implémentation. Ce n'est pas un vague aperçu, c'est une spécification détaillée avec des chemins de fichiers exacts, des signatures de fonctions et un ordre d'implémentation.

Le plan comprend huit sections complètes :
- **Vue d'ensemble** : L'objectif et l'approche de haut niveau
- **Types** : Définitions de types complètes et structures de données
- **Fichiers** : Fichiers exacts à créer, modifier ou supprimer
- **Fonctions** : Fonctions nouvelles et modifiées avec signatures
- **Classes** : Modifications de classes et détails d'héritage
- **Dépendances** : Exigences et versions des packages
- **Tests** : Stratégies de validation et exigences de test
- **Ordre d'implémentation** : Séquence d'exécution étape par étape

### Étape 4 : Création de tâches d'implémentation

Caret crée une nouvelle tâche qui fait référence au document de plan et inclut des étapes d'implémentation suivables. La tâche est livrée avec des commandes spécifiques pour lire chaque section du plan, garantissant que l'agent d'implémentation (que ce soit vous ou Caret en Act Mode) peut naviguer efficacement dans le plan.

<Tip>
  Deep Planning fonctionne à merveille avec [Focus Chain](/french/features/focus-chain). Les étapes d'implémentation deviennent automatiquement une liste de tâches avec suivi des progrès en temps réel, ce qui permet de garder les projets complexes organisés et sur la bonne voie.
</Tip>

## Utilisation de Deep Planning

Démarrez une session de deep planning en tapant `/deep-planning` suivi de la description de votre fonctionnalité :

```
/deep-planning Add user authentication with JWT tokens and role-based access control
```

Caret commencera immédiatement son investigation. Vous le verrez lire des fichiers et exécuter des commandes pour comprendre votre codebase. Une fois qu'il aura recueilli suffisamment de contexte, il entamera une discussion avec vous avant de créer le plan.

## Exemple de flux de travail

Voici comment j'utilise `/deep-planning` pour une fonctionnalité réelle :

<Steps>
  <Step title="Lancer la planification">
    Je tape `/deep-planning implement a caching layer for API responses`
  </Step>
  <Step title="Investigation silencieuse">
    Caret explore ma codebase, en examinant :
    - La structure et les endpoints de l'API actuelle
    - Les modèles de flux de données existants
    - Les requêtes de base de données et les goulots d'étranglement des performances
    - La configuration et la configuration de l'environnement
  </Step>
  <Step title="Discussion ciblée">
    Caret me demande :
    - "Devrions-nous utiliser Redis ou la mise en cache en mémoire ?"
    - "Quelle est la tolérance acceptable de la mise en cache des données utilisateur ?"
    - "Avez-vous besoin de webhooks d'invalidation de cache ?"
  </Step>
  <Step title="Création de plan">
    Caret génère `implementation_plan.md` avec :
    - Les spécifications de la classe de service de cache
    - La configuration de la connexion Redis
    - Les endpoints d'API modifiés avec la logique de mise en cache
    - Les stratégies de génération de clés de cache
    - Les configurations TTL pour différents types de données
  </Step>
  <Step title="Génération de tâches">
    Caret crée une nouvelle tâche avec :
    - Une référence au plan d'implémentation
    - Des commandes pour lire des sections spécifiques
    - Des éléments de tâches suivables pour chaque étape d'implémentation
    - Une demande de passage en Act Mode pour l'exécution
  </Step>
</Steps>

## Intégration avec le mode Plan/Act

Deep Planning est conçu pour fonctionner de manière transparente avec [Plan/Act Mode](/french/features/plan-and-act) :

- Utilisez `/deep-planning` en Plan Mode pour les phases d'investigation et de planification
- La tâche générée demande de passer en Act Mode pour l'implémentation
- Focus Chain suit automatiquement les progrès à travers les étapes d'implémentation

Cette séparation garantit que la planification reste axée sur l'architecture, tandis que l'implémentation reste axée sur l'exécution.

## Meilleures pratiques

### Quand utiliser Deep Planning

Utilisez `/deep-planning` pour :
- Les fonctionnalités touchant plusieurs parties de votre codebase
- Les modifications architecturales nécessitant une coordination minutieuse
- Les intégrations complexes avec des services externes
- Les efforts de refactorisation qui nécessitent une exécution systématique
- Toute fonctionnalité pour laquelle vous passeriez normalement du temps à faire du whiteboarding

### Tirer le meilleur parti de l'investigation

Laissez Caret terminer son investigation de manière approfondie. La qualité du plan est directement corrélée à la qualité de sa compréhension de votre codebase. Si vous avez des domaines spécifiques qu'il devrait examiner, mentionnez-les dans votre demande initiale.

### Examen du plan

Examinez toujours `implementation_plan.md` avant de commencer l'implémentation. Le plan est complet mais pas immuable : vous pouvez le modifier directement si nécessaire. Considérez-le comme un document collaboratif entre vous et Caret.

### Suivi des progrès

Avec Focus Chain activé, votre progression d'implémentation s'affiche dans l'en-tête de la tâche. Chaque étape terminée est cochée automatiquement au fur et à mesure que Caret travaille sur le plan, ce qui vous donne une visibilité en temps réel sur les implémentations complexes.

## Inspiration

J'utilise `/deep-planning` chaque fois que je suis sur le point de créer quelque chose qui nécessiterait normalement un document de conception. Voici quelques exemples récents de mon flux de travail :

- **Migration des systèmes d'authentification** : Deep Planning a cartographié chaque endpoint, identifié tous les points de contact d'authentification et créé un plan de migration qui a évité les modifications majeures.

- **Ajout de fonctionnalités en temps réel** : Le plan couvrait l'intégration WebSocket, la gestion des événements, la synchronisation de l'état et les mécanismes de secours en cas de déconnexion.

- **Refactorisation du schéma de base de données** : Caret a identifié toutes les requêtes affectées, créé des scripts de migration et planifié le déploiement afin de minimiser les temps d'arrêt.

- **Implémentation du versionnage de l'API** : Le plan détaillait les modifications de routes, les couches de compatibilité descendante, les avis de dépréciation et les chemins de migration des clients.

La puissance de `/deep-planning` réside dans le fait qu'il force une architecture réfléchie avant l'implémentation. C'est comme si un développeur expérimenté examinait votre approche avant que vous n'écriviez de code, sauf que ce développeur a une connaissance parfaite de l'ensemble de votre codebase.

<Note>
  Deep Planning nécessite des modèles dotés de fortes capacités de raisonnement. Il fonctionne mieux avec la dernière génération de modèles, tels que GPT-5, Claude 4, Gemini 2.5 ou Grok 4. Les modèles plus petits peuvent avoir des difficultés avec l'analyse complète requise.
</Note>

Pour les tâches plus simples qui ne nécessitent pas de planification approfondie, envisagez d'utiliser [/newtask](/french/features/slash-commands/new-task) pour créer des tâches ciblées avec du contexte, ou passez directement à l'implémentation si la voie à suivre est claire.
